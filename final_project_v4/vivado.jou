#-----------------------------------------------------------
# Vivado v2024.2 (64-bit)
# SW Build 5239630 on Fri Nov 08 22:35:27 MST 2024
# IP Build 5239520 on Sun Nov 10 16:12:51 MST 2024
# SharedData Build 5239561 on Fri Nov 08 14:39:27 MST 2024
# Start of session at: Sun Aug 17 18:52:54 2025
# Process ID         : 22612
# Current directory  : C:/Users/Dustin.Mock/code/ece383/final_project_v4
# Command line       : vivado.exe -gui_launcher_event rodinguilauncherevent28640 C:\Users\Dustin.Mock\code\ece383\final_project_v4\final_project_v4.xpr
# Log file           : C:/Users/Dustin.Mock/code/ece383/final_project_v4/vivado.log
# Journal file       : C:/Users/Dustin.Mock/code/ece383/final_project_v4\vivado.jou
# Running On         : C26-5CG2151GFM
# Platform           : Windows Server 2016 or Windows 10
# Operating System   : 22631
# Processor Detail   : 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz
# CPU Frequency      : 2803 MHz
# CPU Physical cores : 4
# CPU Logical cores  : 8
# Host memory        : 16374 MB
# Swap memory        : 13958 MB
# Total Virtual      : 30333 MB
# Available Virtual  : 7273 MB
#-----------------------------------------------------------
start_gui
open_project C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.xpr
update_compile_order -fileset sources_1
open_bd_design {C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/sources_1/bd/system/system.bd}
apply_bd_automation -rule xilinx.com:bd_rule:mig_7series -config {Board_Interface "ddr3_sdram" }  [get_bd_cells mig_7series_0]
set_property location {4 1738 -153} [get_bd_cells mig_7series_0]
startgroup
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {Auto} Clk_xbar {Auto} Master {/microblaze_0 (Periph)} Slave {/axi_intc_0/s_axi} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins axi_intc_0/s_axi]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {Auto} Clk_xbar {Auto} Master {/microblaze_0 (Periph)} Slave {/axi_timer_0/S_AXI} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins axi_timer_0/S_AXI]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {Auto} Clk_xbar {Auto} Master {/microblaze_0 (Periph)} Slave {/axi_uartlite_0/S_AXI} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins axi_uartlite_0/S_AXI]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {usb_uart ( USB UART ) } Manual_Source {Auto}}  [get_bd_intf_pins axi_uartlite_0/UART]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {Auto} Clk_xbar {Auto} Master {/microblaze_0 (Periph)} Slave {/axi_vdma_0/S_AXI_LITE} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins axi_vdma_0/S_AXI_LITE]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {sys_clock ( System Clock ) } Manual_Source {Auto}}  [get_bd_pins clk_wiz_0/clk_in1]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {reset ( Reset ) } Manual_Source {Auto}}  [get_bd_pins clk_wiz_0/reset]
apply_bd_automation -rule xilinx.com:bd_rule:bram_cntlr -config {BRAM "Auto" }  [get_bd_intf_pins lmb_bram_if_cntlr_0/BRAM_PORT]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {reset ( Reset ) } Manual_Source {Auto}}  [get_bd_pins proc_sys_reset_0/ext_reset_in]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {reset ( Reset ) } Manual_Source {Auto}}  [get_bd_pins rst_pix/ext_reset_in]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {Auto} Clk_xbar {Auto} Master {/microblaze_0 (Periph)} Slave {/v_tc_0/ctrl} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins v_tc_0/ctrl]
endgroup
startgroup
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {/clk_wiz_0/clk_sys (100 MHz)} Clk_xbar {/clk_wiz_0/clk_sys (100 MHz)} Master {/microblaze_0/M_AXI_DC} Slave {/axi_intc_0/s_axi} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins microblaze_0/M_AXI_DC]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {/clk_wiz_0/clk_sys (100 MHz)} Clk_xbar {/clk_wiz_0/clk_sys (100 MHz)} Master {/microblaze_0/M_AXI_IC} Slave {/axi_intc_0/s_axi} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins microblaze_0/M_AXI_IC]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {/clk_wiz_0/clk_sys (100 MHz)} Clk_xbar {/clk_wiz_0/clk_sys (100 MHz)} Master {/microblaze_0/M_AXI_IP} Slave {/axi_intc_0/s_axi} ddr_seg {Auto} intc_ip {/axi_interconnect_0} master_apm {0}}  [get_bd_intf_pins microblaze_0/M_AXI_IP]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {sys_clock ( System Clock ) } Manual_Source {Auto}}  [get_bd_pins microblaze_mcs_0/Clk]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {reset ( Reset ) } Manual_Source {Auto}}  [get_bd_pins microblaze_mcs_0/Reset]
apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/clk_wiz_0/clk_sys (100 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}}  [get_bd_pins mig_7series_0/clk_ref_i]
apply_bd_automation -rule xilinx.com:bd_rule:axi4 -config { Clk_master {/clk_wiz_0/clk_sys (100 MHz)} Clk_slave {/mig_7series_0/ui_clk (100 MHz)} Clk_xbar {Auto} Master {/microblaze_0 (Cached)} Slave {/mig_7series_0/S_AXI} ddr_seg {Auto} intc_ip {New AXI SmartConnect} master_apm {0}}  [get_bd_intf_pins mig_7series_0/S_AXI]
apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/clk_wiz_0/clk_sys (100 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}}  [get_bd_pins mig_7series_0/sys_clk_i]
apply_bd_automation -rule xilinx.com:bd_rule:board -config { Board_Interface {reset ( Reset ) } Manual_Source {Auto}}  [get_bd_pins mig_7series_0/sys_rst]
endgroup
# Exports the open block design to a Tcl script
# Tip: omit -no_mig_contents if you want the MIG .prj details embedded
file mkdir ./bd_dump
write_bd_tcl -force -include_layout -no_ip_version -no_mig_contents ./bd_dump/system_bd.tcl
validate_bd_design
# Writes address assignments (one CSV line per segment)
assign_bd_address -export_to_file ./bd_dump/address_map.csv -force
report_ip_status -file ./bd_dump/ip_status.txt
file mkdir ./bd_dump
# Cells + VLNV
set f [open ./bd_dump/bd_cells.txt w]
puts $f "BD cells (name : VLNV)"
foreach c [lsort [get_bd_cells]] {
  puts $f [format "%s : %s" $c [get_property VLNV $c]]
}
close $f
# Top-level scalar/vector ports
set f [open ./bd_dump/bd_ports.txt w]
puts $f "Top-level ports"
foreach p [lsort [get_bd_ports]] {
  puts $f $p
}
close $f
# Interface ports (e.g., DDR, AXI)
set f [open ./bd_dump/bd_intf_ports.txt w]
puts $f "Top-level interface ports"
foreach p [lsort [get_bd_intf_ports]] {
  puts $f [format "%s : %s" $p [get_property VLNV $p]]
}
close $f
# Interface connections (shows who’s wired to who on AXI/Video/DDR buses)
set f [open ./bd_dump/bd_intf_conns.txt w]
puts $f "Interface connections (pin <-> pin)"
foreach n [lsort [get_bd_intf_nets]] {
  set pins [lsort [get_bd_intf_pins -of_objects $n]]
  puts $f [join $pins "  <->  "]
}
close $f
# Clock/reset nets only, so the file stays small
set f [open ./bd_dump/bd_clk_reset_nets.txt w]
puts $f "Selected nets (clk/rst/areset only)"
foreach n [lsort [get_bd_nets]] {
  set nm [get_property NAME $n]
  if {[regexp -nocase {(clk|rst|areset)} $nm]} {
    set pins [lsort [get_bd_pins -of_objects $n]]
    puts $f "$nm : [join $pins {, }]"
  }
}
close $f
make_bd_intf_pins_external [get_bd_intf_pins mig_7series_0/DDR3]
# 2a) Hook VDMA read master into the memory interconnect
connect_bd_intf_net [get_bd_intf_pins axi_vdma_0/M_AXI_MM2S] \
                    [get_bd_intf_pins axi_interconnect_0/S04_AXI]
# 3a) AXI4-Stream: VDMA MM2S -> Video Out
connect_bd_intf_net [get_bd_intf_pins axi_vdma_0/M_AXIS_MM2S] \
                    [get_bd_intf_pins v_axi4s_vid_out_0/vid_axi4s]
# Grow axi_interconnect_0 to add S04_AXI
set ic [get_bd_cells axi_interconnect_0]
set_property CONFIG.NUM_SI 5 $ic
# Hook the new S04 slot to the MIG/UI clock domain (same as your DDR fabric)
connect_bd_net [get_bd_pins mig_7series_0/ui_clk]            [get_bd_pins axi_interconnect_0/S04_ACLK]
connect_bd_net [get_bd_pins rst_mig_7series_0_100M/peripheral_aresetn] \
               [get_bd_pins axi_interconnect_0/S04_ARESETN]
connect_bd_intf_net [get_bd_intf_pins axi_vdma_0/M_AXI_MM2S] \
                    [get_bd_intf_pins axi_interconnect_0/S04_AXI]
# Detach the pixel clock if it's currently driving the VDMA memory aclk
set vdma_mem_aclk_pin  [get_bd_pins axi_vdma_0/m_axi_mm2s_aclk]
set old_net [get_bd_nets -of_objects $vdma_mem_aclk_pin]
if {$old_net ne ""} { disconnect_bd_net $old_net $vdma_mem_aclk_pin }
# Reclock to DDR fabric
connect_bd_net [get_bd_pins mig_7series_0/ui_clk] $vdma_mem_aclk_pin
# AXI4-Stream clock at PixelClk
connect_bd_net [get_bd_pins clk_wiz_0/pix_clk] \
               [get_bd_pins axi_vdma_0/m_axis_mm2s_aclk]
# AXI4-Stream: VDMA -> AXI4S-to-Video Out
connect_bd_intf_net [get_bd_intf_pins axi_vdma_0/M_AXIS_MM2S] \
                    [get_bd_intf_pins v_axi4s_vid_out_0/vid_axi4s]
undo
clear
# ---------- 0) Helper: function to connect if both pins exist ----------
proc _safe_connect {net pinA pinB} {
  if {[llength [get_bd_pins -quiet $pinA]] && [llength [get_bd_pins -quiet $pinB]]} {
    if {![llength [get_bd_nets -quiet $net]]} { create_bd_net $net }
    catch { connect_bd_net [get_bd_nets $net] [get_bd_pins $pinA] [get_bd_pins $pinB] }
  }
}
proc _safe_iconnect {pinA pinB} {
  if {[llength [get_bd_intf_pins -quiet $pinA]] && [llength [get_bd_intf_pins -quiet $pinB]]} {
    catch { connect_bd_intf_net [get_bd_intf_pins $pinA] [get_bd_intf_pins $pinB] }
  }
}
# ---------- 1) AXI interconnect: add a slave slot for VDMA MM2S ----------
set ic [get_bd_cells -quiet axi_interconnect_0]
if {$ic ne ""} {
  set cur_si [get_property CONFIG.NUM_SI $ic]
  if {$cur_si < 5} { set_property CONFIG.NUM_SI 5 $ic }
  # Clock/reset for S04 slot = MIG UI clock domain
  _safe_connect axi_ic_S04_ACLK   mig_7series_0/ui_clk  axi_interconnect_0/S04_ACLK
  _safe_connect axi_ic_S04_ARESET rst_mig_7series_0_100M/peripheral_aresetn axi_interconnect_0/S04_ARESETN
}
# ---------- 2) VDMA memory master  interconnect S04 ----------
_safe_iconnect axi_vdma_0/M_AXI_MM2S axi_interconnect_0/S04_AXI
# ---------- 3) VDMA clocks: memory on MIG ui_clk, stream on PixelClk ----------
# Memory/read side
if {[llength [get_bd_pins -quiet axi_vdma_0/m_axi_mm2s_aclk]]} {
  # detach any old net
  set p [get_bd_pins axi_vdma_0/m_axi_mm2s_aclk]
  set n [get_bd_nets -of $p]
  if {$n ne ""} { catch {disconnect_bd_net $n $p} }
  _safe_connect vdma_mm2s_mem_aclk mig_7series_0/ui_clk axi_vdma_0/m_axi_mm2s_aclk
}
# Stream/AXIS side (name is m_axis_mm2s_aclk in your design)
if {[llength [get_bd_pins -quiet axi_vdma_0/m_axis_mm2s_aclk]]} {
  _safe_connect vdma_mm2s_axis_aclk clk_wiz_0/pix_clk axi_vdma_0/m_axis_mm2s_aclk
}
# ---------- 4) VDMA stream pins  v_axi4s_vid_out_0 (scalar pins) ----------
# VDMA -> VideoOut
_safe_connect vdma_tdata  axi_vdma_0/m_axis_mm2s_tdata  v_axi4s_vid_out_0/s_axis_video_tdata
_safe_connect vdma_tlast  axi_vdma_0/m_axis_mm2s_tlast  v_axi4s_vid_out_0/s_axis_video_tlast
_safe_connect vdma_tuser  axi_vdma_0/m_axis_mm2s_tuser  v_axi4s_vid_out_0/s_axis_video_tuser
_safe_connect vdma_tvalid axi_vdma_0/m_axis_mm2s_tvalid v_axi4s_vid_out_0/s_axis_video_tvalid
# Backpressure tready
_safe_connect vdma_tready v_axi4s_vid_out_0/s_axis_video_tready axi_vdma_0/m_axis_mm2s_tready
# ---------- 5) Disable unused VDMA write (S2MM) channel ----------
if {[llength [get_bd_cells -quiet axi_vdma_0]]} {
  set_property -dict [list CONFIG.c_include_s2mm {0}] [get_bd_cells axi_vdma_0]
}
# ---------- 6) LMB BRAM controller cleanup ----------
# You have microblaze_0_local_memory already. If lmb_bram_if_cntlr_0 is stray, delete it; else give it a clock.
if {[llength [get_bd_cells -quiet lmb_bram_if_cntlr_0]]} {
  # If it's not used by MicroBlaze, delete it and its BRAM
  set used_by_mb [llength [get_bd_intf_nets -quiet -of [get_bd_intf_pins -quiet microblaze_0/DLMB]]]
  if {!$used_by_mb} {
    catch { delete_bd_objs [get_bd_cells lmb_bram_if_cntlr_0 lmb_bram_if_cntlr_0_bram] }
  } else {
    _safe_connect lmb_clk microblaze_0/Clk lmb_bram_if_cntlr_0/LMB_Clk
  }
}
# ---------- 7) Video Out clock/reset (just to be sure) ----------
_safe_connect vid_out_aclk    clk_wiz_0/pix_clk             v_axi4s_vid_out_0/aclk
_safe_connect vid_out_aresetn rst_pix/peripheral_aresetn    v_axi4s_vid_out_0/aresetn
# ---------- 8) rgb2dvi hookups ----------
# Pixel & serial clocks
_safe_connect rgb2dvi_pixclk  clk_wiz_0/pix_clk  rgb2dvi_0/PixelClk
_safe_connect rgb2dvi_serclk  clk_wiz_0/ser_clk  rgb2dvi_0/SerialClk
# Active-high reset for rgb2dvi: invert rst_pix/peripheral_reset if you have util_vector_logic_0
_safe_connect rgb2dvi_arst    util_vector_logic_0/Res rgb2dvi_0/aRst
# Parallel video from Video Out
_safe_connect vid_vde    v_axi4s_vid_out_0/vid_active_video rgb2dvi_0/vid_pVDE
_safe_connect vid_hs     v_axi4s_vid_out_0/vid_hsync        rgb2dvi_0/vid_pHSync
_safe_connect vid_vs     v_axi4s_vid_out_0/vid_vsync        rgb2dvi_0/vid_pVSync
_safe_connect vid_data   v_axi4s_vid_out_0/vid_data         rgb2dvi_0/vid_pData
# ---------- 9) MIG clocks ----------
# Keep sys_clk_i at 100 MHz. Feed clk_ref_i with 200 MHz if your clk_wiz exposes it.
if {[llength [get_bd_pins -quiet mig_7series_0/sys_clk_i]]} {
  _safe_connect mig_sysclk clk_wiz_0/clk_sys mig_7series_0/sys_clk_i
}
if {[llength [get_bd_pins -quiet clk_wiz_0/clk_ref_200]] && [llength [get_bd_pins -quiet mig_7series_0/clk_ref_i]]} {
  _safe_connect mig_refclk clk_wiz_0/clk_ref_200 mig_7series_0/clk_ref_i
}
# ---------- 10) Export DDR3 interface if missing ----------
if {![llength [get_bd_intf_ports -quiet DDR3]]} {
  catch { make_bd_intf_pins_external [get_bd_intf_pins mig_7series_0/DDR3] }
}
# ---------- 11) Validate & save ----------
validate_bd_design
# --- Video Out aresetn must be ACTIVE_LOW (use rst_pix/peripheral_aresetn)
if {[llength [get_bd_pins -quiet v_axi4s_vid_out_0/aresetn]]} {
  set p  [get_bd_pins v_axi4s_vid_out_0/aresetn]
  set n  [get_bd_nets -of $p]
  if {$n ne ""} { catch {disconnect_bd_net $n $p} }
  connect_bd_net [get_bd_pins rst_pix/peripheral_aresetn] $p
}
# --- VDMA axi_resetn must be ACTIVE_LOW from the AXI-Lite domain reset
# Prefer the proc_sys_reset that clocks the s_axi_lite_aclk domain (usually proc_sys_reset_0)
if {[llength [get_bd_pins -quiet axi_vdma_0/axi_resetn]]} {
  set p  [get_bd_pins axi_vdma_0/axi_resetn]
  set n  [get_bd_nets -of $p]
  if {$n ne ""} { catch {disconnect_bd_net $n $p} }
  connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] $p
}
# --- rgb2dvi expects ACTIVE_HIGH 'aRst'  drive it directly from the pixel-domain active-high reset
if {[llength [get_bd_pins -quiet rgb2dvi_0/aRst]]} {
  set p  [get_bd_pins rgb2dvi_0/aRst]
  set n  [get_bd_nets -of $p]
  if {$n ne ""} { catch {disconnect_bd_net $n $p} }
  # Use the active-high reset from the pixel domain
  connect_bd_net [get_bd_pins rst_pix/peripheral_reset] $p
}
# Optional: if util_vector_logic_0 was only for rgb2dvi reset, you can remove it:
# catch { delete_bd_objs [get_bd_cells util_vector_logic_0] }
# Create/overwrite an address segment: VDMA MM2S master -> MIG DDR space
set dma_as   [get_bd_addr_spaces  axi_vdma_0/Data_MM2S]
set mig_seg  [get_bd_addr_segs    mig_7series_0/memmap/memaddr]
# Remove any stale segment in this address space pointing at MIG (safe if none)
foreach s [get_bd_addr_segs -quiet -of $dma_as] {
  if {[string match *memmap/memaddr [get_property NAME $s]]} {
    catch { delete_bd_objs $s }
  }
}
# Map the VDMA MM2S master to DDR: 0x80000000..0x9FFFFFFF (512MB example)
create_bd_addr_seg -range 0x20000000 -offset 0x80000000 $dma_as $mig_seg SEG_VDMA_MM2S_to_DDR
# Exclude peripheral register windows from the VDMA master (optional but silences warnings)
foreach seg {
  axi_timer_0/S_AXI/Reg
  axi_intc_0/S_AXI/Reg
  axi_uartlite_0/S_AXI/Reg
  axi_vdma_0/S_AXI_LITE/Reg
  v_tc_0/ctrl/Reg
} {
  set s [get_bd_addr_segs -quiet $seg]
  if {[llength $s]} {
    catch { exclude_bd_addr_seg -target_address_space $dma_as $s }
  }
}
validate_bd_design
assign_bd_address
# Optional: export again
# assign_bd_address -export_to_file ./bd_dump/address_map.csv -force
save_bd_design
# =====  A) Make rgb2dvi reset synchronous to SerialClk, fix reset polarities  =====
# Create a proc_sys_reset for the 5x TMDS (SerialClk) domain
if {![llength [get_bd_cells -quiet rst_ser]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:5.0 rst_ser
}
# Clock it with SerialClk, use same external reset & CLK Wiz lock
connect_bd_net [get_bd_pins clk_wiz_0/ser_clk]      [get_bd_pins rst_ser/slowest_sync_clk]
connect_bd_net [get_bd_pins proc_sys_reset_0/ext_reset_in] [get_bd_pins rst_ser/ext_reset_in]
if {[llength [get_bd_pins -quiet clk_wiz_0/locked]]} {
  connect_bd_net [get_bd_pins clk_wiz_0/locked]     [get_bd_pins rst_ser/dcm_locked]
}
# v_axi4s_vid_out_0: aresetn must be ACTIVE_LOW and synchronous to PixelClk
# (rst_pix/peripheral_aresetn is already that)
set p [get_bd_pins -quiet v_axi4s_vid_out_0/aresetn]
if {$p ne ""} {
  set n [get_bd_nets -of $p]; if {$n ne ""} {catch {disconnect_bd_net $n $p}}
  connect_bd_net [get_bd_pins rst_pix/peripheral_aresetn] $p
}
# VDMA AXI-Lite reset (ACTIVE_LOW) should come from proc_sys_reset_0
set p [get_bd_pins -quiet axi_vdma_0/axi_resetn]
if {$p ne ""} {
  set n [get_bd_nets -of $p]; if {$n ne ""} {catch {disconnect_bd_net $n $p}}
  connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] $p
}
# rgb2dvi aRst is ACTIVE_HIGH — drive it from a reset synchronous to SerialClk
set p [get_bd_pins -quiet rgb2dvi_0/aRst]
if {$p ne ""} {
  set n [get_bd_nets -of $p]; if {$n ne ""} {catch {disconnect_bd_net $n $p}}
  connect_bd_net [get_bd_pins rst_ser/peripheral_reset] $p
}
# =====  B) Delete stray, driverless helper nets the earlier script created  =====
foreach n {
  axi_ic_S04_ACLK axi_ic_S04_ARESET lmb_clk mig_sysclk
  rgb2dvi_arst rgb2dvi_pixclk rgb2dvi_serclk
  vdma_mm2s_axis_aclk vdma_mm2s_mem_aclk
  vdma_tdata vdma_tlast vdma_tready vdma_tuser vdma_tvalid
  vid_data vid_hs vid_vde vid_vs vid_out_aclk vid_out_aresetn
} {
  catch { delete_bd_objs [get_bd_nets $n] }
}
# =====  C) Remove or fix the stray LMB BRAM controller  =====
# If it's not the one MicroBlaze is using, delete it (and its BRAM).
if {[llength [get_bd_cells -quiet lmb_bram_if_cntlr_0]]} {
  # Check if microblaze_0 uses microblaze_0_local_memory already; if so, nuke the extra controller.
  if {[llength [get_bd_cells -quiet microblaze_0_local_memory]]} {
    catch { delete_bd_objs [get_bd_cells lmb_bram_if_cntlr_0 lmb_bram_if_cntlr_0_bram] }
  } else {
    # Fallback: at least clock it so validation passes
    connect_bd_net [get_bd_pins microblaze_0/Clk] [get_bd_pins lmb_bram_if_cntlr_0/LMB_Clk]
  }
}
# =====  D) Tie off axi_intc_0/intr to 0 (or delete the intc if unused)  =====
if {[llength [get_bd_cells -quiet axi_intc_0]]} {
  if {![llength [get_bd_cells -quiet xlconstant_intr0]]} {
    create_bd_cell -type ip -vlnv xilinx.com:ip:xlconstant:1.1 xlconstant_intr0
    set_property -dict [list CONFIG.CONST_VAL {0} CONFIG.CONST_WIDTH {1}] [get_bd_cells xlconstant_intr0]
  }
  # Connect constant 0 to INTC intr (handles width=1)
  if {[llength [get_bd_pins -quiet axi_intc_0/intr]]} {
    connect_bd_net [get_bd_pins xlconstant_intr0/dout] [get_bd_pins axi_intc_0/intr]
  }
}
# =====  E) Re-validate & save  =====
validate_bd_design
assign_bd_address
save_bd_design
# 1) If a stray top-level LMB BRAM controller exists, delete it (and its BRAM)
set stray_lmbs [get_bd_cells -quiet -filter {NAME =~ "lmb_bram_if_cntlr_*"}]
if {[llength $stray_lmbs]} {
  # Try deleting any BRAM paired with it first (name usually ends with _bram)
  foreach c $stray_lmbs {
    set bram [get_bd_cells -quiet ${c}_bram]
    if {$bram ne ""} { catch { delete_bd_objs $bram } }
    catch { delete_bd_objs $c }
  }
}
# 2) (Safety) If an LMB controller still remains, at least clock it so it won’t complain
if {[llength [get_bd_cells -quiet lmb_bram_if_cntlr_0]]} {
  connect_bd_net [get_bd_pins microblaze_0/Clk] [get_bd_pins lmb_bram_if_cntlr_0/LMB_Clk]
  # Tie off the remaining LMB control pins to zero to silence validation (rarely needed)
  if {![llength [get_bd_cells -quiet xlconstant_lmb0]]} {
    create_bd_cell -type ip -vlnv xilinx.com:ip:xlconstant:1.1 xlconstant_lmb0
    set_property -dict [list CONFIG.CONST_VAL {0} CONFIG.CONST_WIDTH {32}] [get_bd_cells xlconstant_lmb0]
  }
  foreach p {LMB_ABus LMB_AddrStrobe LMB_ReadStrobe} {
    if {[llength [get_bd_pins -quiet lmb_bram_if_cntlr_0/$p]]} {
      connect_bd_net [get_bd_pins xlconstant_lmb0/dout] [get_bd_pins lmb_bram_if_cntlr_0/$p]
    }
  }
}
# 3) Validate, assign addresses, save
validate_bd_design
assign_bd_address
save_bd_design
startgroup
set_property -dict [list \
  CONFIG.CLKOUT1_JITTER {130.958} \
  CONFIG.CLKOUT1_PHASE_ERROR {98.575} \
  CONFIG.CLKOUT2_JITTER {159.371} \
  CONFIG.CLKOUT2_PHASE_ERROR {98.575} \
  CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {40} \
  CONFIG.CLKOUT3_JITTER {114.829} \
  CONFIG.CLKOUT3_PHASE_ERROR {98.575} \
  CONFIG.CLKOUT3_REQUESTED_OUT_FREQ {200} \
  CONFIG.CLKOUT4_JITTER {114.829} \
  CONFIG.CLKOUT4_PHASE_ERROR {98.575} \
  CONFIG.CLKOUT4_REQUESTED_OUT_FREQ {200} \
  CONFIG.CLKOUT4_USED {true} \
  CONFIG.CLK_OUT4_PORT {clk_ref_200} \
  CONFIG.MMCM_CLKFBOUT_MULT_F {10.000} \
  CONFIG.MMCM_CLKOUT0_DIVIDE_F {10.000} \
  CONFIG.MMCM_CLKOUT1_DIVIDE {25} \
  CONFIG.MMCM_CLKOUT2_DIVIDE {5} \
  CONFIG.MMCM_CLKOUT3_DIVIDE {5} \
  CONFIG.NUM_OUT_CLKS {4} \
] [get_bd_cells clk_wiz_0]
endgroup
disconnect_bd_net /microblaze_0_Clk [get_bd_pins mig_7series_0/clk_ref_i]
connect_bd_net [get_bd_pins mig_7series_0/clk_ref_i] [get_bd_pins clk_wiz_0/clk_ref_200]
startgroup
set_property -dict [list \
  CONFIG.GEN_F0_VBLANK_HEND {840} \
  CONFIG.GEN_F0_VBLANK_HSTART {840} \
  CONFIG.GEN_F0_VFRAME_SIZE {628} \
  CONFIG.GEN_F0_VSYNC_HEND {840} \
  CONFIG.GEN_F0_VSYNC_HSTART {840} \
  CONFIG.GEN_F0_VSYNC_VEND {605} \
  CONFIG.GEN_F0_VSYNC_VSTART {601} \
  CONFIG.GEN_HACTIVE_SIZE {800} \
  CONFIG.GEN_HFRAME_SIZE {1056} \
  CONFIG.GEN_HSYNC_END {968} \
  CONFIG.GEN_HSYNC_START {840} \
  CONFIG.GEN_VACTIVE_SIZE {600} \
  CONFIG.VIDEO_MODE {Custom} \
] [get_bd_cells v_tc_0]
endgroup
validate_bd_design
save_bd_design
launch_runs impl_1 -to_step write_bitstream -jobs 4
make_wrapper -files [get_files C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/sources_1/bd/system/system.bd] -top
add_files -norecurse c:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.gen/sources_1/bd/system/hdl/system_wrapper.vhd
update_compile_order -fileset sources_1
# Remove the unnecessary inverter to clear width-mismatch warnings
if {[llength [get_bd_cells -quiet util_vector_logic_0]]} {
  delete_bd_objs [get_bd_cells util_vector_logic_0]
}
validate_bd_design
save_bd_design
launch_runs impl_1 -to_step write_bitstream -jobs 4
wait_on_run impl_1
write_hw_platform -fixed -include_bit -force -file C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.xsa
# If a stray reset_0 external port exists, delete it
if {[llength [get_bd_ports -quiet reset_0]]} {
  # Disconnect anything on it
  foreach p [get_bd_pins -quiet -of_objects [get_bd_ports reset_0]] {
    catch { disconnect_bd_net -net [get_bd_nets -of $p] $p }
  }
  delete_bd_objs [get_bd_ports reset_0]
}
# Make sure proc_sys_reset_0 gets the external 'reset' port
if {![llength [get_bd_ports -quiet reset]]} {
  make_bd_pins_external [get_bd_pins proc_sys_reset_0/ext_reset_in]
  set_property name reset [get_bd_ports ext_reset_in_0]
} else {
  connect_bd_net [get_bd_ports reset] [get_bd_pins proc_sys_reset_0/ext_reset_in]
}
# If you added rst_ser (SerialClk domain), feed it from the same external reset:
if {[llength [get_bd_cells -quiet rst_ser]]} {
  connect_bd_net [get_bd_ports reset] [get_bd_pins rst_ser/ext_reset_in]
}
# 1) Find the existing reset net that drives proc_sys_reset_0/ext_reset_in
set rst_pin  [get_bd_pins -quiet proc_sys_reset_0/ext_reset_in]
set rst_net  [get_bd_nets -quiet -of_objects $rst_pin]
# 2) Pick whichever external reset port you already have (reset or reset_1 or ext_reset_in_0)
set ext_rst_port ""
foreach cand {reset reset_1 ext_reset_in_0} {
  if {[llength [get_bd_ports -quiet $cand]]} { set ext_rst_port $cand; break }
}
# If none exists, make one from the existing reset net
if {$ext_rst_port eq ""} {
  make_bd_pins_external $rst_pin
  set ext_rst_port [lindex [get_bd_ports -quiet] end]  ;# whatever Vivado just created
  # Optional: rename it to 'reset'
  catch { set_property name reset [get_bd_ports $ext_rst_port] }
}
# 3) Put that external port on the SAME net as proc_sys_reset_0/ext_reset_in
#    (This avoids creating a new net and triggering the "already connected" error.)
connect_bd_net $rst_net [get_bd_ports $ext_rst_port]
# Find the reset pin and its existing net
set rst_pin  [get_bd_pins -quiet proc_sys_reset_0/ext_reset_in]
set rst_net  [get_bd_nets  -quiet -of_objects $rst_pin]
# If that net already has an external port, use it; else create one
set rst_ports [get_bd_ports -quiet -of_objects $rst_net]
if {[llength $rst_ports] == 0} {
  make_bd_pins_external $rst_pin
  set rst_ports [get_bd_ports -quiet -of_objects $rst_net]
}
# Keep the first external port, rename it to 'reset'
set rst_port [lindex $rst_ports 0]
catch { set_property name reset $rst_port }
# Delete any extra external reset ports on the same net (avoid LOC conflicts)
for {set i 1} {$i < [llength $rst_ports]} {incr i} {
  catch { delete_bd_objs [lindex $rst_ports $i] }
}
# If you have rst_ser (SerialClk domain), put its ext_reset_in on this net too
if {[llength [get_bd_cells -quiet rst_ser]]} {
  connect_bd_net $rst_net [get_bd_pins rst_ser/ext_reset_in]
}
# === normalize the main external reset ===
# 1) Find the PSR pin and the net it already sits on
set rst_pin  [get_bd_pins  -quiet proc_sys_reset_0/ext_reset_in]
set rst_net  [get_bd_nets  -quiet -of_objects $rst_pin]
# 2) Ensure that net has exactly ONE external port, named 'reset'
set net_ports [get_bd_ports -quiet -of_objects $rst_net]
if {[llength $net_ports] == 0} {
  make_bd_pins_external $rst_pin
  set net_ports [get_bd_ports -quiet -of_objects $rst_net]
}
# Pick the keeper port
set keep_port ""
if {[llength [get_bd_ports -quiet reset]]} {
  set keep_port [get_bd_ports -quiet reset]
  # If keep_port isn't on rst_net yet, force it onto rst_net
  if {![llength [get_bd_ports -quiet -of_objects $rst_net]]} {
    # unlikely, but just in case:
    connect_bd_net $rst_net $keep_port
  }
} else {
  # rename the first port on the net to 'reset' (ignore if it already exists)
  set keep_port [lindex $net_ports 0]
  catch { set_property name reset $keep_port }
  # Re-fetch in case Vivado had to rename to reset_1 etc.
  if {![llength [get_bd_ports -quiet reset]]} {
    # fall back to whatever the first port is
    set keep_port [lindex [get_bd_ports -quiet -of_objects $rst_net] 0]
  } else {
    set keep_port [get_bd_ports -quiet reset]
  }
}
# Delete any other external reset-like ports on the SAME net to avoid LOC clashes
foreach p $net_ports {
  if {$p ne $keep_port} { catch { delete_bd_objs $p } }
}
# === hook other reset generators to the SAME external reset net ===
# Helper: connect a pin to the 'reset' port's net (disconnect old if needed)
proc _join_reset_net {pin_name} {
  if {![llength [get_bd_pins -quiet $pin_name]]} { return }
  set p [get_bd_pins $pin_name]
  set n [get_bd_nets -quiet -of_objects $p]
  if {$n ne ""} { catch { disconnect_bd_net $n $p } }
  # use two-endpoint form to avoid net-object quirks
  connect_bd_net [get_bd_ports reset] $p
}
# If you have rst_ser (SerialClk domain), attach its ext_reset_in to 'reset'
if {[llength [get_bd_cells -quiet rst_ser]]} {
  _join_reset_net rst_ser/ext_reset_in
}
# Pixel-domain proc_sys_reset (if not already on the same net)
_join_reset_net proc_sys_reset_0/ext_reset_in
validate_bd_design
save_bd_design
if {[llength [get_bd_cells -quiet microblaze_mcs_0]]} {
  delete_bd_objs [get_bd_cells microblaze_mcs_0]
}
## HDMI Source (J8) TMDS outputs — Digilent Nexys Video (XC7A200T SBG484)
## I/O standard for all TMDS differential outputs
set_property IOSTANDARD TMDS_33 [get_ports {hdmi_tx_clk_p}]
file mkdir C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/constrs_1
file mkdir C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/constrs_1/new
close [ open C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/constrs_1/new/nexys_hdmi.xdc w ]
add_files -fileset constrs_1 C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/constrs_1/new/nexys_hdmi.xdc
open_project C:/Users/Dustin.Mock/code/ece383/Lab2/Lab2.xpr
update_compile_order -fileset sources_1
current_project final_project_v4
# ========= 1) Create/ensure a 5-bit top-level 'btn[4:0]' input port =========
if {![llength [get_bd_ports -quiet btn]]} {
  create_bd_port -dir I -from 4 -to 0 btn
}
# ========= 2) Create the AXI GPIO for buttons (inputs only) =========
set gpio_name axi_gpio_btn
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
# Make it 5 bits, all inputs, single channel, (optional) enable interrupt = 1 to use with AXI INTC
set_property -dict [list \
  CONFIG.C_GPIO_WIDTH {5} \
  CONFIG.C_ALL_INPUTS {1} \
  CONFIG.C_ALL_OUTPUTS {0} \
  CONFIG.C_IS_DUAL {0} \
  CONFIG.C_INTERRUPT_PRESENT {1} \
] [get_bd_cells $gpio_name]
# Connect the buttons to the GPIO input bus
# (gpio_io_i width is 5; this ties the whole vector)
connect_bd_net [get_bd_ports btn] [get_bd_pins $gpio_name/gpio_io_i]
# ========= 3) Clocks & resets for the GPIO & its AXI-Lite =========
# Use your 100 MHz system clock and proc_sys_reset_0 for aresetn
connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                 [get_bd_pins $gpio_name/s_axi_aclk]
connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins $gpio_name/s_axi_aresetn]
# ========= 4) Hook S_AXI to the interconnect on a free M port =========
# Helper: find a free Mxx_AXI slot (grow NUM_MI if needed)
proc _connect_slave_to_ic {ip_path} {
  set ic [get_bd_cells -quiet axi_interconnect_0]
  if {$ic eq ""} { error "axi_interconnect_0 not found" }

  # Ensure enough MI slots exist
  set num_mi [get_property CONFIG.NUM_MI $ic]
  # Find a free one
  set free_idx -1
  for {set i 0} {$i < $num_mi} {incr i} {
    set pin [format "axi_interconnect_0/M%02d_AXI" $i]
    if {![llength [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins -quiet $pin]]]} {
      set free_idx $i; break
    }
  }
  if {$free_idx < 0} {
    incr num_mi
    set_property CONFIG.NUM_MI $num_mi $ic
    set free_idx [expr {$num_mi-1}]
  }
  set tgt_pin [format "axi_interconnect_0/M%02d_AXI" $free_idx]

  # Clock/reset that MI slot with the same sys clock/reset as other peripherals
  # (These pins exist when NUM_MI >= free_idx+1)
  set mi_aclk   [format "axi_interconnect_0/M%02d_ACLK"   $free_idx]
  set mi_areset [format "axi_interconnect_0/M%02d_ARESETN" $free_idx]
  if {[llength [get_bd_pins -quiet $mi_aclk]]} {
    connect_bd_net [get_bd_pins clk_wiz_0/clk_sys] $mi_aclk
  }
  if {[llength [get_bd_pins -quiet $mi_areset]]} {
    connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] $mi_areset
  }

  # Now connect the AXI-Lite slave to that MI slot
  connect_bd_intf_net [get_bd_intf_pins ${ip_path}/S_AXI] [get_bd_intf_pins $tgt_pin]
}
_connect_slave_to_ic $gpio_name
current_project Lab2
current_project final_project_v4
# ========= 1) Create/ensure a 5-bit top-level 'btn[4:0]' input port =========
if {![llength [get_bd_ports -quiet btn]]} {
  create_bd_port -dir I -from 4 -to 0 btn
}
# ========= 2) Create the AXI GPIO for buttons (inputs only) =========
set gpio_name axi_gpio_btn
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
# Make it 5 bits, all inputs, single channel, (optional) enable interrupt = 1 to use with AXI INTC
set_property -dict [list \
  CONFIG.C_GPIO_WIDTH {5} \
  CONFIG.C_ALL_INPUTS {1} \
  CONFIG.C_ALL_OUTPUTS {0} \
  CONFIG.C_IS_DUAL {0} \
  CONFIG.C_INTERRUPT_PRESENT {1} \
] [get_bd_cells $gpio_name]
# Connect the buttons to the GPIO input bus
# (gpio_io_i width is 5; this ties the whole vector)
connect_bd_net [get_bd_ports btn] [get_bd_pins $gpio_name/gpio_io_i]
# =========================
# AXI GPIO for buttons
# =========================
set gpio_name axi_gpio_btn
# 0) Ensure top-level 5-bit btn[4:0] exists
if {![llength [get_bd_ports -quiet btn]]} {
  create_bd_port -dir I -from 4 -to 0 btn
}
# 1) Create/configure AXI GPIO
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
set_property -dict [list \
  CONFIG.C_GPIO_WIDTH {5} \
  CONFIG.C_ALL_INPUTS {1} \
  CONFIG.C_ALL_OUTPUTS {0} \
  CONFIG.C_IS_DUAL {0} \
  CONFIG.C_INTERRUPT_PRESENT {1} \
] [get_bd_cells $gpio_name]
# 2) Connect btn[4:0] -> gpio_io_i (avoid "already connected" error)
set btn_port [get_bd_ports -quiet btn]
set btn_pin  [get_bd_pins  -quiet $gpio_name/gpio_io_i]
if {$btn_port ne "" && $btn_pin ne ""} {
  set net_port [get_bd_nets -quiet -of_objects $btn_port]
  set net_pin  [get_bd_nets -quiet -of_objects $btn_pin]
  if {$net_pin eq ""} {
    catch { connect_bd_net $btn_port $btn_pin }
  } elseif {$net_port ne "" && $net_port ne $net_pin} {
    catch { disconnect_bd_net $net_pin $btn_pin }
    catch { connect_bd_net $btn_port $btn_pin }
  }
}
# 3) Clock/reset to system domain (100 MHz / proc_sys_reset_0)
catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                      [get_bd_pins $gpio_name/s_axi_aclk] }
catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn]    [get_bd_pins $gpio_name/s_axi_aresetn] }
# 4) Hook S_AXI to an interconnect master slot (grow if needed)
proc connect_axi_slave_to_ic {slave_cell} {
  # Prefer axi_interconnect_0, else fall back to axi_smc_0 (SmartConnect)
  set ic [get_bd_cells -quiet axi_interconnect_0]
  set smc [get_bd_cells -quiet axi_smc_0]
  if {$ic eq "" && $smc eq ""} { error "No AXI interconnect/smartconnect found." }

  if {$ic ne ""} {
    # ----- AXI Interconnect path -----
    # Find or create a free Mxx slot
    set num_mi [get_property CONFIG.NUM_MI $ic]
    set free_idx -1
    for {set i 0} {$i < $num_mi} {incr i} {
      set m_if [format "axi_interconnect_0/M%02d_AXI" $i]
      set used [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins -quiet $m_if]]
      if {![llength $used]} { set free_idx $i; break }
    }
    if {$free_idx < 0} {
      incr num_mi
      set_property CONFIG.NUM_MI $num_mi $ic
      set free_idx [expr {$num_mi-1}]
    }
    set m_if   [format "axi_interconnect_0/M%02d_AXI"    $free_idx]
    set m_aclk [format "axi_interconnect_0/M%02d_ACLK"   $free_idx]
    set m_rstn [format "axi_interconnect_0/M%02d_ARESETN" $free_idx]

    # Connect interface
    catch { connect_bd_intf_net [get_bd_intf_pins ${slave_cell}/S_AXI] [get_bd_intf_pins $m_if] }

    # Clocking for that slot if pins exist, else use global ACLK/ARESETN
    if {[llength [get_bd_pins -quiet $m_aclk]]} {
      catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys] [get_bd_pins $m_aclk] }
    } else {
      catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys] [get_bd_pins axi_interconnect_0/ACLK] }
    }
    if {[llength [get_bd_pins -quiet $m_rstn]]} {
      catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins $m_rstn] }
    } else {
      catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins axi_interconnect_0/ARESETN] }
    }
  } else {
    # ----- SmartConnect path (axi_smc_0) -----
    # Find a free Mxx_AXI on SmartConnect
    set mi_cnt [get_property CONFIG.NUM_MI [get_bd_cells axi_smc_0]]
    set free_idx -1
    for {set i 0} {$i < $mi_cnt} {incr i} {
      set m_if [format "axi_smc_0/M%02d_AXI" $i]
      set used [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins -quiet $m_if]]
      if {![llength $used]} { set free_idx $i; break }
    }
    if {$free_idx < 0} {
      incr mi_cnt
      set_property CONFIG.NUM_MI $mi_cnt [get_bd_cells axi_smc_0]
      set free_idx [expr {$mi_cnt-1}]
    }
    set m_if [format "axi_smc_0/M%02d_AXI" $free_idx]
    catch { connect_bd_intf_net [get_bd_intf_pins ${slave_cell}/S_AXI] [get_bd_intf_pins $m_if] }
    # SmartConnect uses a single ACLK/ARESETN
    catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                   [get_bd_pins axi_smc_0/aclk] }
    catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins axi_smc_0/aresetn] }
  }
}
connect_axi_slave_to_ic $gpio_name
# 5) Optional: connect interrupt to axi_intc_0 (bit 0)
if {[llength [get_bd_cells -quiet axi_intc_0]]} {
  if {[llength [get_bd_pins -quiet axi_intc_0/intr[0]]]} {
    catch { connect_bd_net [get_bd_pins $gpio_name/ip2intc_irpt] [get_bd_pins axi_intc_0/intr[0]] }
  } elseif {[llength [get_bd_pins -quiet axi_intc_0/intr]]} {
    catch { connect_bd_net [get_bd_pins $gpio_name/ip2intc_irpt] [get_bd_pins axi_intc_0/intr] }
  }
  catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                   [get_bd_pins axi_intc_0/s_axi_aclk] }
  catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins axi_intc_0/s_axi_aresetn] }
}
# 6) Address, validate, save
assign_bd_address
validate_bd_design
save_bd_design
current_project Lab2
close_project
current_project final_project_v4
# =========================
# AXI GPIO for buttons
# =========================
set gpio_name axi_gpio_btn
# 0) Ensure top-level 5-bit btn[4:0] exists
if {![llength [get_bd_ports -quiet btn]]} {
  create_bd_port -dir I -from 4 -to 0 btn
}
# 1) Create/configure AXI GPIO
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
set_property -dict [list \
  CONFIG.C_GPIO_WIDTH {5} \
  CONFIG.C_ALL_INPUTS {1} \
  CONFIG.C_ALL_OUTPUTS {0} \
  CONFIG.C_IS_DUAL {0} \
  CONFIG.C_INTERRUPT_PRESENT {1} \
] [get_bd_cells $gpio_name]
# 2) Connect btn[4:0] -> gpio_io_i (avoid "already connected" error)
set btn_port [get_bd_ports -quiet btn]
set btn_pin  [get_bd_pins  -quiet $gpio_name/gpio_io_i]
if {$btn_port ne "" && $btn_pin ne ""} {
  set net_port [get_bd_nets -quiet -of_objects $btn_port]
  set net_pin  [get_bd_nets -quiet -of_objects $btn_pin]
  if {$net_pin eq ""} {
    catch { connect_bd_net $btn_port $btn_pin }
  } elseif {$net_port ne "" && $net_port ne $net_pin} {
    catch { disconnect_bd_net $net_pin $btn_pin }
    catch { connect_bd_net $btn_port $btn_pin }
  }
}
# 3) Clock/reset to system domain (100 MHz / proc_sys_reset_0)
catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                      [get_bd_pins $gpio_name/s_axi_aclk] }
catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn]    [get_bd_pins $gpio_name/s_axi_aresetn] }
# 4) Hook S_AXI to an interconnect master slot (grow if needed)
proc connect_axi_slave_to_ic {slave_cell} {
  # Prefer axi_interconnect_0, else fall back to axi_smc_0 (SmartConnect)
  set ic [get_bd_cells -quiet axi_interconnect_0]
  set smc [get_bd_cells -quiet axi_smc_0]
  if {$ic eq "" && $smc eq ""} { error "No AXI interconnect/smartconnect found." }

  if {$ic ne ""} {
    # ----- AXI Interconnect path -----
    # Find or create a free Mxx slot
    set num_mi [get_property CONFIG.NUM_MI $ic]
    set free_idx -1
    for {set i 0} {$i < $num_mi} {incr i} {
      set m_if [format "axi_interconnect_0/M%02d_AXI" $i]
      set used [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins -quiet $m_if]]
      if {![llength $used]} { set free_idx $i; break }
    }
    if {$free_idx < 0} {
      incr num_mi
      set_property CONFIG.NUM_MI $num_mi $ic
      set free_idx [expr {$num_mi-1}]
    }
    set m_if   [format "axi_interconnect_0/M%02d_AXI"    $free_idx]
    set m_aclk [format "axi_interconnect_0/M%02d_ACLK"   $free_idx]
    set m_rstn [format "axi_interconnect_0/M%02d_ARESETN" $free_idx]

    # Connect interface
    catch { connect_bd_intf_net [get_bd_intf_pins ${slave_cell}/S_AXI] [get_bd_intf_pins $m_if] }

    # Clocking for that slot if pins exist, else use global ACLK/ARESETN
    if {[llength [get_bd_pins -quiet $m_aclk]]} {
      catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys] [get_bd_pins $m_aclk] }
    } else {
      catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys] [get_bd_pins axi_interconnect_0/ACLK] }
    }
    if {[llength [get_bd_pins -quiet $m_rstn]]} {
      catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins $m_rstn] }
    } else {
      catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins axi_interconnect_0/ARESETN] }
    }
  } else {
    # ----- SmartConnect path (axi_smc_0) -----
    # Find a free Mxx_AXI on SmartConnect
    set mi_cnt [get_property CONFIG.NUM_MI [get_bd_cells axi_smc_0]]
    set free_idx -1
    for {set i 0} {$i < $mi_cnt} {incr i} {
      set m_if [format "axi_smc_0/M%02d_AXI" $i]
      set used [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins -quiet $m_if]]
      if {![llength $used]} { set free_idx $i; break }
    }
    if {$free_idx < 0} {
      incr mi_cnt
      set_property CONFIG.NUM_MI $mi_cnt [get_bd_cells axi_smc_0]
      set free_idx [expr {$mi_cnt-1}]
    }
    set m_if [format "axi_smc_0/M%02d_AXI" $free_idx]
    catch { connect_bd_intf_net [get_bd_intf_pins ${slave_cell}/S_AXI] [get_bd_intf_pins $m_if] }
    # SmartConnect uses a single ACLK/ARESETN
    catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                   [get_bd_pins axi_smc_0/aclk] }
    catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins axi_smc_0/aresetn] }
  }
}
connect_axi_slave_to_ic $gpio_name
# 5) Optional: connect interrupt to axi_intc_0 (bit 0)
if {[llength [get_bd_cells -quiet axi_intc_0]]} {
  if {[llength [get_bd_pins -quiet axi_intc_0/intr[0]]]} {
    catch { connect_bd_net [get_bd_pins $gpio_name/ip2intc_irpt] [get_bd_pins axi_intc_0/intr[0]] }
  } elseif {[llength [get_bd_pins -quiet axi_intc_0/intr]]} {
    catch { connect_bd_net [get_bd_pins $gpio_name/ip2intc_irpt] [get_bd_pins axi_intc_0/intr] }
  }
  catch { connect_bd_net [get_bd_pins clk_wiz_0/clk_sys]                   [get_bd_pins axi_intc_0/s_axi_aclk] }
  catch { connect_bd_net [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins axi_intc_0/s_axi_aresetn] }
}
# 6) Address, validate, save
assign_bd_address
validate_bd_design
save_bd_design
make_wrapper -files [get_files C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/sources_1/bd/system/system.bd] -top
reset_run synth_1
reset_run system_axi_interconnect_0_imp_xbar_0_synth_1
reset_run system_mig_7series_0_1_synth_1
launch_runs impl_1 -to_step write_bitstream -jobs 4
wait_on_run impl_1
# Targets the open design "system" in project final_project_v4
current_project final_project_v4
open_bd_design [get_files *.bd]
# 1) GPIO clock/reset -> sys domain (use correct get_bd_pins form)
connect_bd_net [get_bd_pins clk_wiz_0/clk_sys] \
               [get_bd_pins axi_gpio_btn/s_axi_aclk]
report_compile_order -constraints -used_in synthesis
# OR gpio irq into an existing INTC source
if {![llength [get_bd_cells -quiet util_or_irq]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:util_vector_logic:2.0 util_or_irq
  set_property -dict [list CONFIG.C_OPERATION {or} CONFIG.C_SIZE {1}] [get_bd_cells util_or_irq]
}
# If INTC already has a driver on 'intr', move it into Op1
set intr_pin  [get_bd_pins -quiet axi_intc_0/intr]
set intr_net  [get_bd_nets -quiet -of_objects $intr_pin]
set old_src ""
foreach p [get_bd_pins -quiet -of_objects $intr_net] {
  if {[get_property DIR $p] eq "O" && ![regexp {axi_intc_0/intr} $p]} { set old_src $p; break }
}
if {$old_src ne ""} {
  catch { disconnect_bd_net $intr_net $intr_pin }
  connect_bd_net [get_bd_pins util_or_irq/Op1] $old_src
  connect_bd_net [get_bd_pins util_or_irq/Op2] [get_bd_pins axi_gpio_btn/ip2intc_irpt]
  connect_bd_net [get_bd_pins util_or_irq/Res] $intr_pin
} else {
  # No previous source: drive INTC directly from GPIO
  catch { connect_bd_net [get_bd_pins axi_gpio_btn/ip2intc_irpt] $intr_pin }
}
validate_bd_design
save_bd_design
reset_run synth_1
reset_run system_mig_7series_0_1_synth_1
reset_run system_axi_intc_0_0_synth_1
launch_runs impl_1 -to_step write_bitstream -jobs 4
wait_on_run impl_1
open_run impl_1
report_methodology
reset_run synth_1
launch_runs impl_1 -to_step write_bitstream -jobs 4
wait_on_run impl_1
close_design
# Inspect actual pins
report_bd_pins -hier [get_bd_cells axi_interconnect_0] | grep -nocase ACLK
# Example pattern: only connect if not already connected
set saxi [get_bd_intf_pins <periph_name>/S_AXI]
if {[llength [get_bd_intf_nets -of_objects $saxi]] == 0} {
  connect_bd_intf_net $saxi [get_bd_intf_pins axi_interconnect_0/M0x_AXI]
}
# Inspect actual pins
report_bd_pins -hier [get_bd_cells axi_interconnect_0] | grep -nocase ACLK
# Example pattern: only connect if not already connected
set saxi [get_bd_intf_pins <periph_name>/S_AXI]
if {[llength [get_bd_intf_nets -of_objects $saxi]] == 0} {
  connect_bd_intf_net $saxi [get_bd_intf_pins axi_interconnect_0/M0x_AXI]
}
# Clear spurious backbone requirement on clk_sys, if present
set _clk_nets [get_nets -hier -quiet *clk_wiz_0*clk_sys*]
if {[llength $_clk_nets]} { set_property CLOCK_DEDICATED_ROUTE AUTO $_clk_nets }
## --- Fix TIMING-4 / TIMING-27: remove bad primary clocks on MIG internal pins
# If MIG's .xdc created a primary clock on its internal sys_clk_i pin, drop it.
if {[llength [get_pins -quiet system_i/mig_7series_0/sys_clk_i]]} {
  remove_clocks -of_objects [get_pins system_i/mig_7series_0/sys_clk_i]
}
# Some MIG configs also create a clock on the internal 200-MHz ref pin. Drop it if present.
if {[llength [get_pins -quiet system_i/mig_7series_0/clk_ref_i]]} {
  remove_clocks -of_objects [get_pins system_i/mig_7series_0/clk_ref_i]
}
puts [get_ports {btn[*]}]
puts [get_ports {btn[*]}]
current_design
open_bd_design [get_files -quiet *system.bd]
current_bd_design [get_bd_designs]
# Inspect interconnect
set IC axi_interconnect_0
puts "M slots: [lsort [get_bd_intf_pins -quiet ${IC}/M*_AXI]]"
puts "S slots: [lsort [get_bd_intf_pins -quiet ${IC}/S*_AXI]]"
puts "ACLKs :  [get_bd_pins -quiet ${IC}/*ACLK]"
puts "ARESETNs:[get_bd_pins -quiet ${IC}/*ARESETN]"
# Drive ALL *ACLK / *ARESETN from fabric clock/reset (only if unconnected)
set FAB_CLK  [get_bd_pins -quiet clk_wiz_0/clk_out1]
set FAB_RSTN [get_bd_pins -quiet rst_mig_7series_0_100M/peripheral_aresetn]
if {![llength $FAB_RSTN]} { set FAB_RSTN [get_bd_pins -quiet rst_mig_7series_0_100M/interconnect_aresetn] }
foreach c [get_bd_pins -quiet ${IC}/*ACLK] {
  if {![llength [get_bd_nets -quiet -of_objects $c]] && [llength $FAB_CLK]} {
    connect_bd_net -quiet $FAB_CLK $c
  }
}
foreach r [get_bd_pins -quiet ${IC}/*ARESETN] {
  if {![llength [get_bd_nets -quiet -of_objects $r]] && [llength $FAB_RSTN]} {
    connect_bd_net -quiet $FAB_RSTN $r
  }
}
# Ensure axi_gpio_btn S_AXI is connected to a free M* slot (if not already)
set P axi_gpio_btn
set SAXI [get_bd_intf_pins -quiet ${P}/S_AXI]
if {[llength $SAXI]} {
  if {![llength [get_bd_intf_nets -quiet -of_objects $SAXI]]} {
    set FREE {}
    foreach m [lsort [get_bd_intf_pins -quiet ${IC}/M*_AXI]] {
      if {![llength [get_bd_intf_nets -quiet -of_objects $m]]} { set FREE $m; break }
    }
    if {$FREE ne {}} {
      connect_bd_intf_net $SAXI $FREE
      puts "Connected ${P}/S_AXI -> $FREE"
    } else {
      puts "No free ${IC}/M*_AXI slot."
    }
  } else { puts "${P}/S_AXI already connected." }
} else {
  puts "No pin ${P}/S_AXI found."
}
# Fix interrupt fan-in: util_or_irq -> axi_intc_0/intr, sources feed util_or_irq
set INTC_INTR   [get_bd_pins -quiet axi_intc_0/intr]
set OR_RES      [get_bd_pins -quiet util_or_irq/Res]
set GPIO_IRQ    [get_bd_pins -quiet axi_gpio_btn/ip2intc_irpt]
if {[llength $INTC_INTR] && [llength $OR_RES]} {
  set intr_net [get_bd_nets -quiet -of_objects $INTC_INTR]
  if {[llength $intr_net]} { disconnect_bd_net -net $intr_net $INTC_INTR }
  connect_bd_net -quiet $OR_RES $INTC_INTR
}
# Open your project & the block design
open_project C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.xpr
# See if the external BD ports exist
puts "BD btn ports:  [get_bd_ports -quiet btn[*]]"
puts "BD reset port: [get_bd_ports -quiet reset_n]"
# Export AXI GPIO inputs as external port named "btn"
if {![llength [get_bd_ports -quiet btn]]} {
  set p [get_bd_pins -quiet axi_gpio_btn/gpio_io_i]
  if {[llength $p]} {
    make_bd_pins_external $p
    set new [lindex [get_bd_ports -quiet gpio_io_i*] 0]
    set_property name btn $new
  }
}
# Create an active-low reset_n port and hook it up (adjust pin names if yours differ)
if {![llength [get_bd_ports -quiet reset_n]]} {
  create_bd_port -dir I -type rst reset_n
  set_property CONFIG.POLARITY ACTIVE_LOW [get_bd_ports reset_n]
  if {[llength [get_bd_pins -quiet reset_inv_0/Op1]] && [llength [get_bd_pins -quiet proc_sys_reset_0/ext_reset_in]]} {
    connect_bd_net [get_bd_ports reset_n] [get_bd_pins reset_inv_0/Op1]
    connect_bd_net [get_bd_pins reset_inv_0/Res] [get_bd_pins proc_sys_reset_0/ext_reset_in]
  }
}
# --- Rewire interrupts cleanly ---
# Pins we care about
set INTC_INTR   [get_bd_pins axi_intc_0/intr]
set OR_RES      [get_bd_pins util_or_irq/Res]
set GPIO_IRQ    [get_bd_pins axi_gpio_btn/ip2intc_irpt]
# 1) Disconnect anything currently driving axi_intc_0/intr
foreach n [get_bd_nets -quiet -of_objects $INTC_INTR] {
  disconnect_bd_net $n $INTC_INTR
}
# 2) Feed gpio irq into the OR block (use the first free Op* pin)
set FREE_OP {}
foreach op [lsort [get_bd_pins -quiet util_or_irq/Op*]] {
  if {![llength [get_bd_nets -quiet -of_objects $op]]} { set FREE_OP $op; break }
}
if {$FREE_OP ne {} && [llength $GPIO_IRQ]} {
  connect_bd_net $GPIO_IRQ $FREE_OP
} else {
  puts "No free util_or_irq Op* input found (or GPIO IRQ missing)."
}
# 3) Drive the interrupt controller from the OR result
connect_bd_net $OR_RES $INTC_INTR
validate_bd_design
save_bd_design
puts "BD ports: [get_bd_ports -quiet btn[*]]  reset: [get_bd_ports -quiet reset_n]"
puts "BD ports: [get_bd_ports -quiet btn[*]]  reset: [get_bd_ports -quiet reset_n]"
# export buttons from axi_gpio_btn (inputs)
make_bd_pins_external [get_bd_pins axi_gpio_btn/gpio_io_i]
set_property name btn [get_bd_ports gpio_io_i_0]
# === 1) Open & validate the BD
open_bd_design [get_files -quiet *system.bd]
validate_bd_design
save_bd_design
# === 2) Create an export folder
set outdir [file normalize "./_share_bd"]
file mkdir $outdir
# === 3) Export the block design to Tcl (small, portable)
write_bd_tcl   -force $outdir/system_bd.tcl
# (optional) also capture the canvas/layout, if supported
if {[catch {write_bd_layout -force $outdir/system_bd_layout.tcl [get_bd_designs system]} msg]} {
  puts "note: write_bd_layout not available or not needed: $msg"
}
# === 4) Include constraints you authored (copy any XDCs you’re using)
foreach x [get_files -quiet *.xdc] { file copy -force $x $outdir }
# === 5) Useful context for review
# Top-level BD ports (so we can see what must be constrained)
set fp [open "$outdir/bd_ports.txt" w]
foreach p [lsort [get_bd_ports]] { puts $fp $p }
close $fp
# IP status & versions (helps spot mismatches)
report_ip_status -name ip_status
file copy -force ip_status.rpt $outdir/
# Full BD cell/property dump (handy diff/reference)
report_property -all [get_bd_cells] > $outdir/bd_cells_props.rpt
archive_project -force $outdir/system_project_archive.zip
open_bd_design [get_files -quiet *system.bd]
#---------- 1) Fix MIG resets/clocks ----------
# ext_reset_in should come from an external active-HIGH reset.
# If you have reset_n + reset_inv_0, use its output; else point to /reset (active-high).
set rst_pin [get_bd_pins -quiet rst_mig_7series_0_100M/ext_reset_in]
if {[llength $rst_pin]} {
  set cur [get_bd_nets -quiet -of_objects $rst_pin]
  if {[llength $cur]} { disconnect_bd_net -net $cur $rst_pin }
  if {[llength [get_bd_pins -quiet reset_inv_0/Res]]} {
    connect_bd_net [get_bd_pins reset_inv_0/Res] $rst_pin
  } elseif {[llength [get_bd_ports -quiet reset]]} {
    connect_bd_net [get_bd_ports reset] $rst_pin
  } else {
    puts "NOTE: Provide an active-high reset to rst_mig_7series_0_100M/ext_reset_in"
  }
}
open_bd_design [get_files -quiet *system.bd]
# Helpers
set PIXCLK  [get_bd_pins -quiet clk_wiz_0/pix_clk]
set PIXRSTN [get_bd_pins -quiet rst_pix/peripheral_aresetn]
# (a) AXI4-Stream clocks (pixel domain)
foreach p {
  axi_vdma_0/m_axis_mm2s_aclk
  v_axi4s_vid_out_0/aclk
  v_tc_0/clk
  rgb2dvi_0/PixelClk
} {
  if {[llength [get_bd_pins -quiet $p]] && [llength $PIXCLK]} {
    if {![llength [get_bd_nets -quiet -of_objects [get_bd_pins $p]]]} {
      connect_bd_net $PIXCLK [get_bd_pins $p]
    }
  }
}
# (b) Pixel-domain resets (active-low)
# v_axi4s_vid_out & v_tc are typical; VDMA may not expose a separate AXIS reset—skip if absent.
foreach p {
  v_axi4s_vid_out_0/aresetn
  v_tc_0/resetn
} {
  if {[llength [get_bd_pins -quiet $p]] && [llength $PIXRSTN]} {
    if {![llength [get_bd_nets -quiet -of_objects [get_bd_pins $p]]]} {
      connect_bd_net $PIXRSTN [get_bd_pins $p]
    }
  }
}
# (c) VTC timing -> video_out timing
if {![llength [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins v_axi4s_vid_out_0/vtiming_in]]]} {
  if {[llength [get_bd_intf_pins -quiet v_tc_0/vtiming_out]]} {
    connect_bd_intf_net [get_bd_intf_pins v_tc_0/vtiming_out] [get_bd_intf_pins v_axi4s_vid_out_0/vtiming_in]
  }
}
# (d) AXI-Lite clock/reset for VDMA control (fabric domain)
if {[llength [get_bd_pins -quiet axi_vdma_0/s_axi_lite_aclk]] && [llength [get_bd_pins -quiet clk_wiz_0/clk_out1]]} {
  if {![llength [get_bd_nets -quiet -of_objects [get_bd_pins axi_vdma_0/s_axi_lite_aclk]]]} {
    connect_bd_net [get_bd_pins clk_wiz_0/clk_out1] [get_bd_pins axi_vdma_0/s_axi_lite_aclk]
  }
}
# Reset pin name varies by version; try both and ignore if missing
foreach rpin {s_axi_lite_aresetn axi_resetn} {
  if {[llength [get_bd_pins -quiet axi_vdma_0/$rpin]] && [llength [get_bd_pins -quiet rst_mig_7series_0_100M/peripheral_aresetn]]} {
    if {![llength [get_bd_nets -quiet -of_objects [get_bd_pins axi_vdma_0/$rpin]]]} {
      connect_bd_net [get_bd_pins rst_mig_7series_0_100M/peripheral_aresetn] [get_bd_pins axi_vdma_0/$rpin]
    }
  }
}
save_bd_design
validate_bd_design
set _clk_nets [get_nets -hier -quiet *clk_wiz_0*clk_sys*]
if {[llength $_clk_nets]} { set_property CLOCK_DEDICATED_ROUTE AUTO $_clk_nets }
# Open your BD first
open_bd_design [get_files -quiet *system.bd]
# -- Create or reuse AXI GPIO for buttons
set gpio_name axi_gpio_btn
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
# Configure: single channel, all inputs, width 5, interrupt present
set_property -dict [list \
  CONFIG.C_IS_DUAL            {0} \
  CONFIG.C_ALL_INPUTS         {1} \
  CONFIG.C_ALL_OUTPUTS        {0} \
  CONFIG.C_GPIO_WIDTH         {5} \
  CONFIG.C_INTERRUPT_PRESENT  {1} \
] [get_bd_cells $gpio_name]
# -- Export buttons to top level as 'btn[4:0]'
#   (disconnect anything already on gpio_io_i, then make it external)
set btn_pin  [get_bd_pins -quiet $gpio_name/gpio_io_i]
if {[llength $btn_pin]} {
  # If already external but wrong name/width, clean it up
  set cur_port [get_bd_ports -quiet -of_objects $btn_pin]
  if {[llength $cur_port]} {
    # If the existing external port isn't 'btn', rename it; ensure it's a bus of width 5
    set p [lindex $cur_port 0]
    if {[string compare [get_property NAME $p] "btn"] != 0} {
      set_property NAME btn $p
    }
    # Width is inherited from the pin; just ensure connection is intact
  } else {
    make_bd_pins_external $btn_pin
    set_property NAME btn [get_bd_ports -quiet [lindex [get_bd_ports -of_objects $btn_pin] 0]]
  }
}
# Open BD
open_bd_design [get_files -quiet *system.bd]
# 0) Sanity: make sure the GPIO cell exists and is configured as 5-bit input w/ IRQ
set gpio_name axi_gpio_btn
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
set_property -dict [list \
  CONFIG.C_IS_DUAL            {0} \
  CONFIG.C_ALL_INPUTS         {1} \
  CONFIG.C_ALL_OUTPUTS        {0} \
  CONFIG.C_GPIO_WIDTH         {5} \
  CONFIG.C_INTERRUPT_PRESENT  {1} \
] [get_bd_cells $gpio_name]
# 1) Export gpio_io_i to a top port named 'btn' (width follows pin = 5)
set btn_pin  [get_bd_pins -quiet $gpio_name/gpio_io_i]
if {![llength $btn_pin]} { error "Can't find $gpio_name/gpio_io_i" }
# If it isn't external yet, make it external and capture the created port
set btn_port [get_bd_ports -quiet -of_objects $btn_pin]
if {![llength $btn_port]} {
  make_bd_pins_external $btn_pin
  set btn_port [get_bd_ports -of_objects $btn_pin]
}
# If the external port exists but isn't named 'btn', rename (or create explicitly if name is taken)
if {[llength $btn_port]} {
  set cur_name [get_property NAME $btn_port]
  if {$cur_name ne "btn"} {
    if {[llength [get_bd_ports -quiet btn]]} {
      # A 'btn' port already exists: re-externalize with that name
      delete_bd_objs $btn_port
      make_bd_pins_external -name btn $btn_pin
      set btn_port [get_bd_ports btn]
    } else {
      set_property NAME btn $btn_port
    }
  }
} else {
  # Fallback: create with explicit name
  make_bd_pins_external -name btn $btn_pin
  set btn_port [get_bd_ports btn]
}
# 2) AXI: connect S_AXI to a free M* slot on axi_interconnect_0 (if not already)
set saxi [get_bd_intf_pins -quiet $gpio_name/S_AXI]
if {[llength $saxi] && ![llength [get_bd_intf_nets -quiet -of_objects $saxi]]} {
  set freeM {}
  foreach m [lsort [get_bd_intf_pins -quiet axi_interconnect_0/M*_AXI]] {
    if {![llength [get_bd_intf_nets -quiet -of_objects $m]]} { set freeM $m; break }
  }
  if {$freeM ne {}} { connect_bd_intf_net $saxi $freeM }
}
# 3) Clocks/resets for the GPIO core (only if floating)
set FAB_CLK  [get_bd_pins -quiet clk_wiz_0/clk_out1]
set FAB_RSTN [get_bd_pins -quiet rst_mig_7series_0_100M/peripheral_aresetn]
if {![llength $FAB_RSTN]} { set FAB_RSTN [get_bd_pins -quiet rst_mig_7series_0_100M/interconnect_aresetn] }
if {[llength $FAB_CLK]} {
  set p [get_bd_pins -quiet $gpio_name/s_axi_aclk]
  if {[llength $p] && ![llength [get_bd_nets -quiet -of_objects $p]]} { connect_bd_net $FAB_CLK $p }
}
if {[llength $FAB_RSTN]} {
  set p [get_bd_pins -quiet $gpio_name/s_axi_aresetn]
  if {[llength $p] && ![llength [get_bd_nets -quiet -of_objects $p]]} { connect_bd_net $FAB_RSTN $p }
}
# 4) Interrupt plumbing (optional but recommended)
# Make sure axi_intc_0/intr is driven by util_or_irq/Res (single source)
if {[llength [get_bd_pins -quiet util_or_irq/Res]] && [llength [get_bd_pins -quiet axi_intc_0/intr]]} {
  set sink [get_bd_pins axi_intc_0/intr]
  set net  [get_bd_nets -quiet -of_objects $sink]
  if {[llength $net]} { disconnect_bd_net -net $net $sink }
  connect_bd_net [get_bd_pins util_or_irq/Res] $sink
}
# Open BD
open_bd_design [get_files -quiet *system.bd]
# ---- Make axi_intc_0/intr <- util_or_irq/Res (single-source) ----
set src_pin  [get_bd_pins -quiet util_or_irq/Res]
set sink_pin [get_bd_pins -quiet axi_intc_0/intr]
if {[llength $src_pin] && [llength $sink_pin]} {
  # 1) Detach sink from any net
  set sink_net [get_bd_nets -quiet -of_objects $sink_pin]
  if {[llength $sink_net]} { disconnect_bd_net -net [lindex $sink_net 0] $sink_pin }

  # 2) If src already has a net, attach sink to THAT net (no merging)
  set src_net [get_bd_nets -quiet -of_objects $src_pin]
  if {[llength $src_net]} {
    connect_bd_net -net [lindex $src_net 0] $sink_pin
  } else {
    # 3) Otherwise, just connect the two pins (creates a new net)
    connect_bd_net $src_pin $sink_pin
  }
}
# Open BD
open_bd_design [get_files -quiet *system.bd]
# ---- Make axi_intc_0/intr <- util_or_irq/Res (single-source) ----
set src_pin  [get_bd_pins -quiet util_or_irq/Res]
set sink_pin [get_bd_pins -quiet axi_intc_0/intr]
if {[llength $src_pin] && [llength $sink_pin]} {
  # 1) Detach sink from any net
  set sink_net [get_bd_nets -quiet -of_objects $sink_pin]
  if {[llength $sink_net]} { disconnect_bd_net -net [lindex $sink_net 0] $sink_pin }

  # 2) If src already has a net, attach sink to THAT net (no merging)
  set src_net [get_bd_nets -quiet -of_objects $src_pin]
  if {[llength $src_net]} {
    connect_bd_net -net [lindex $src_net 0] $sink_pin
  } else {
    # 3) Otherwise, just connect the two pins (creates a new net)
    connect_bd_net $src_pin $sink_pin
  }
}
# Open the BD
open_bd_design [get_files -quiet *system.bd]
# ---------- 0) Ensure/Configure the GPIO-for-buttons ----------
set gpio_name axi_gpio_btn
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
# Single channel, 5 inputs, with interrupt
set_property -dict [list \
  CONFIG.C_IS_DUAL            {0} \
  CONFIG.C_ALL_INPUTS         {1} \
  CONFIG.C_ALL_OUTPUTS        {0} \
  CONFIG.C_GPIO_WIDTH         {5} \
  CONFIG.C_INTERRUPT_PRESENT  {1} \
] [get_bd_cells $gpio_name]
# ---------- 1) Export buttons to top as btn[4:0] ----------
set btn_pin   [get_bd_pins  -quiet $gpio_name/gpio_io_i]
if {![llength $btn_pin]} { error "Can't find $gpio_name/gpio_io_i" }
# If not already external, make it external
set btn_port  [get_bd_ports -quiet -of_objects $btn_pin]
if {![llength $btn_port]} {
  make_bd_pins_external -name btn $btn_pin
  set btn_port [get_bd_ports btn]
} else {
  # Ensure the port name is 'btn'
  if {[get_property NAME [lindex $btn_port 0]] ne "btn"} {
    set_property NAME btn [lindex $btn_port 0]
  }
}
# ---------- 2) Hook AXI Lite of GPIO into the interconnect ----------
# Only connect if the interface is floating
set saxi [get_bd_intf_pins -quiet $gpio_name/S_AXI]
if {[llength $saxi] && ![llength [get_bd_intf_nets -quiet -of_objects $saxi]]} {
  # Pick a free master slot on axi_interconnect_0
  set freeM {}
  foreach m [lsort [get_bd_intf_pins -quiet axi_interconnect_0/M*_AXI]] {
    if {![llength [get_bd_intf_nets -quiet -of_objects $m]]} { set freeM $m; break }
  }
  if {$freeM ne {}} { connect_bd_intf_net $saxi $freeM }
}
# ---------- 3) Drive GPIO clock/reset (only if floating) ----------
set FAB_CLK  [get_bd_pins -quiet clk_wiz_0/clk_out1]
set FAB_RSTN [lindex [concat \
  [get_bd_pins -quiet rst_mig_7series_0_100M/peripheral_aresetn] \
  [get_bd_pins -quiet rst_mig_7series_0_100M/interconnect_aresetn]] 0]
set p [get_bd_pins -quiet $gpio_name/s_axi_aclk]
if {[llength $FAB_CLK] && [llength $p] && ![llength [get_bd_nets -quiet -of_objects $p]]} {
  connect_bd_net $FAB_CLK $p
}
set p [get_bd_pins -quiet $gpio_name/s_axi_aresetn]
if {[llength $FAB_RSTN] && [llength $p] && ![llength [get_bd_nets -quiet -of_objects $p]]} {
  connect_bd_net $FAB_RSTN $p
}
# ---------- 4) Feed the GPIO interrupt into util_or_irq (pick a free Op*) ----------
set irq_pin [get_bd_pins -quiet axi_gpio_btn/ip2intc_irpt]
set freeOp {}
foreach op [lsort [get_bd_pins -quiet util_or_irq/Op*]] {
  if {![llength [get_bd_nets -quiet -of_objects $op]]} { set freeOp $op; break }
}
if {[llength $irq_pin] && $freeOp ne {}} {
  # Don’t specify -net; just connect pin-to-pin so Vivado reuses the IRQ net.
  connect_bd_net $irq_pin $freeOp
}
# ---------- 5) Make util_or_irq/Res the ONLY driver of axi_intc_0/intr ----------
set src_pin  [get_bd_pins -quiet util_or_irq/Res]       ;# source
set sink_pin [get_bd_pins -quiet axi_intc_0/intr]       ;# single sink (vector of 1)
if {[llength $src_pin] && [llength $sink_pin]} {
  # Detach sink from any existing net
  set sink_net [get_bd_nets -quiet -of_objects $sink_pin]
  if {[llength $sink_net]} { disconnect_bd_net -net [lindex $sink_net 0] $sink_pin }

  # Now connect pin-to-pin (NO -net flag to avoid "net can only be specified once")
  connect_bd_net $src_pin $sink_pin
}
# Open BD
open_bd_design [get_files -quiet *system.bd]
# --- Ensure/Configure the GPIO for buttons (5 inputs with IRQ) ---
set gpio_name axi_gpio_btn
if {![llength [get_bd_cells -quiet $gpio_name]]} {
  create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 $gpio_name
}
set_property -dict [list \
  CONFIG.C_IS_DUAL            {0} \
  CONFIG.C_ALL_INPUTS         {1} \
  CONFIG.C_ALL_OUTPUTS        {0} \
  CONFIG.C_GPIO_WIDTH         {5} \
  CONFIG.C_INTERRUPT_PRESENT  {1} \
] [get_bd_cells $gpio_name]
# --- Export buttons to top as btn[4:0] (only if not already) ---
set btn_pin  [get_bd_pins -quiet $gpio_name/gpio_io_i]
if {![llength [get_bd_ports -quiet -of_objects $btn_pin]]} {
  make_bd_pins_external -name btn $btn_pin
} else {
  # ensure name is 'btn'
  set p [lindex [get_bd_ports -quiet -of_objects $btn_pin] 0]
  if {[get_property NAME $p] ne "btn"} { set_property NAME btn $p }
}
# --- Hook AXI-Lite if floating: GPIO -> axi_interconnect_0 ---
set saxi [get_bd_intf_pins -quiet $gpio_name/S_AXI]
if {[llength $saxi] && ![llength [get_bd_intf_nets -quiet -of_objects $saxi]]} {
  set freeM {}
  foreach m [lsort [get_bd_intf_pins -quiet axi_interconnect_0/M*_AXI]] {
    if {![llength [get_bd_intf_nets -quiet -of_objects $m]]} { set freeM $m; break }
  }
  if {$freeM ne {}} { connect_bd_intf_net $saxi $freeM }
}
# --- Drive GPIO clock/reset ONLY if they are floating ---
set FAB_CLK  [get_bd_pins -quiet clk_wiz_0/clk_out1]
set FAB_RSTN [lindex [concat \
  [get_bd_pins -quiet rst_mig_7series_0_100M/peripheral_aresetn] \
  [get_bd_pins -quiet rst_mig_7series_0_100M/interconnect_aresetn]] 0]
set p [get_bd_pins -quiet $gpio_name/s_axi_aclk]
if {[llength $FAB_CLK] && [llength $p] && ![llength [get_bd_nets -quiet -of_objects $p]]} {
  connect_bd_net $FAB_CLK $p
}
set p [get_bd_pins -quiet $gpio_name/s_axi_aresetn]
if {[llength $FAB_RSTN] && [llength $p] && ![llength [get_bd_nets -quiet -of_objects $p]]} {
  connect_bd_net $FAB_RSTN $p
}
# --- Feed GPIO interrupt into util_or_irq (first *free* Op*) ---
set irq_pin [get_bd_pins -quiet axi_gpio_btn/ip2intc_irpt]
if {[llength $irq_pin]} {
  # find a free Op* on util_or_irq; if none, grow input count
  set freeOp {}
  foreach op [lsort [get_bd_pins -quiet util_or_irq/Op*]] {
    if {![llength [get_bd_nets -quiet -of_objects $op]]} { set freeOp $op; break }
  }
  if {$freeOp eq {}} {
    # increase the number of inputs on util_or_irq and use the new last Op*
    set curN [get_property -quiet CONFIG.C_INPUTS [get_bd_cells util_or_irq]]
    if {$curN eq ""} { set curN 1 }
    set_property CONFIG.C_INPUTS [expr {$curN + 1}] [get_bd_cells util_or_irq]
    # re-query the new last Op*
    set freeOp [lindex [lsort [get_bd_pins -quiet util_or_irq/Op*]] end]
  }
  # connect only if that Op* is still free
  if {![llength [get_bd_nets -quiet -of_objects $freeOp]]} {
    connect_bd_net $irq_pin $freeOp
  }
}
# --- DO NOT TOUCH: util_or_irq/Res -> axi_intc_0/intr (already wired) ---
# --- Ensure INTC 'irq' reaches MicroBlaze (only if MB IRQ float) ---
set mb_irq_pin [lindex [concat \
  [get_bd_pins -quiet microblaze_0/Interrupt] \
  [get_bd_pins -quiet microblaze_0/INTERRUPT] \
  [get_bd_pins -quiet microblaze_0/interrupt]] 0]
set intc_irq   [get_bd_pins -quiet axi_intc_0/irq]
if {[llength $mb_irq_pin] && [llength $intc_irq]} {
  if {![llength [get_bd_nets -quiet -of_objects $mb_irq_pin]]} {
    connect_bd_net $intc_irq $mb_irq_pin
  }
}
save_bd_design
validate_bd_design
puts "btn port           : [get_bd_ports btn]"
puts "GPIO->S_AXI net    : [get_bd_intf_nets -quiet -of_objects [get_bd_intf_pins axi_gpio_btn/S_AXI]]"
puts "GPIO irq net       : [get_bd_nets -quiet -of_objects [get_bd_pins axi_gpio_btn/ip2intc_irpt]]"
puts "util_or_irq Res net: [get_bd_nets -quiet -of_objects [get_bd_pins util_or_irq/Res]]"
puts "INTC intr net      : [get_bd_nets -quiet -of_objects [get_bd_pins axi_intc_0/intr]]"
puts "INTC irq -> MB net : [get_bd_nets -quiet -of_objects [get_bd_pins microblaze_0/Interrupt]]"
puts "Buttons : [get_ports -quiet {btn[*]}]"
puts "Reset   : [get_ports -quiet reset]"
puts "UART RX : [get_ports -quiet usb_uart_rxd]"
puts "UART TX : [get_ports -quiet usb_uart_txd]"
puts "HDMI clk: [list [get_ports -quiet hdmi_tx_clk_p] [get_ports -quiet hdmi_tx_clk_n]]"
puts "HDMI d  : [list [get_ports -quiet {hdmi_tx_d_p[*]}] [get_ports -quiet {hdmi_tx_d_n[*]}]]"
make_wrapper -files [get_files C:/Users/Dustin.Mock/code/ece383/final_project_v4/final_project_v4.srcs/sources_1/bd/system/system.bd] -top
reset_run synth_1
reset_run system_microblaze_0_0_synth_1
reset_run system_mig_7series_0_1_synth_1
launch_runs impl_1 -to_step write_bitstream -jobs 4
# Open BD (no net surgery here)
open_bd_design [get_files -quiet *system.bd]
save_bd_design
# Find the MIG IP object (works whether it's named mig_7series_0 or system_mig_7series_0_1, etc.)
set MIG_IP [get_ips -hier -quiet -filter {VLNV =~ "*:mig_7series:*"}]
# --- Open BD (no net surgery) ---
open_bd_design [get_files -quiet *system.bd]
save_bd_design
validate_bd_design
# --- Find the MIG cell(s) inside the BD (works for any name/version) ---
set MIG_CELLS [get_bd_cells -hier -quiet -filter {VLNV =~ "*:mig_7series:*"}]
puts "MIG BD cells: $MIG_CELLS"
if {![llength $MIG_CELLS]} { error "No MIG 7-series cell found in the BD." }
# --- Hard-clean any stale MIG output dirs in the project .gen tree (incl. _tmp) ---
set proj_dir [file normalize [get_property DIRECTORY [current_project]]]
set bd_file  [file normalize [get_files -quiet *system.bd]]
set bd_name  [file rootname [file tail $bd_file]]  ;# usually "system"
# Candidate dirs (Vivado writes BD IP under <proj>.gen/sources_1/bd/<bd_name>/ip/)
set mig_dirs [concat \
  [glob -nocomplain -types d [file join $proj_dir "*.gen" "sources_1" "bd" $bd_name "ip" "*mig_7series*"]] \
  [glob -nocomplain -types d [file join $proj_dir "*.gen" "sources_1" "bd" $bd_name "ip" "system_mig_*"]] \
]
# Also catch stray _tmp folders under ip/
set tmp_dirs [glob -nocomplain -types d [file join $proj_dir "*.gen" "sources_1" "bd" $bd_name "ip" "*" "_tmp"]]
foreach d [concat $mig_dirs $tmp_dirs] {
  puts "Cleaning: $d"
  catch { file attributes $d -readonly 0 }
  catch { file delete -force -- $d }
}
# --- Regenerate only synthesis/implementation products for the BD (skip sim) ---
generate_target {synthesis implementation} [get_files $bd_file]
export_ip_user_files -of_objects [get_files $bd_file] -no_script -quiet -sync -force
# --- Rebuild wrapper, set top, refresh compile order ---
make_wrapper -files [get_files $bd_file] -top -force -import
set_property top system_wrapper [current_fileset]
update_compile_order -fileset sources_1
# --- Optional sanity checks on MIG clocks (should be wired already) ---
puts "sys_clk_i net : [get_bd_nets -quiet -of_objects [get_bd_pins mig_7series_0/sys_clk_i]]"
puts "clk_ref_i net : [get_bd_nets -quiet -of_objects [get_bd_pins mig_7series_0/clk_ref_i]]"
puts "ui_clk net    : [get_bd_nets -quiet -of_objects [get_bd_pins mig_7series_0/ui_clk]]"
# --- Build (stop on DRC issues before bitgen) ---
launch_runs impl_1 -to_step write_bitstream
# In the Vivado Tcl console, with your project open:
if {[llength [get_runs synth_1 -quiet]]} {
  set_property STEPS.SYNTH_DESIGN.TCL.PRE  {} [get_runs synth_1]
  set_property STEPS.SYNTH_DESIGN.TCL.POST {} [get_runs synth_1]
}
if {[llength [get_runs impl_1 -quiet]]} {
  set_property STEPS.OPT_DESIGN.TCL.PRE   {} [get_runs impl_1]
  set_property STEPS.PLACE_DESIGN.TCL.PRE {} [get_runs impl_1]
  set_property STEPS.ROUTE_DESIGN.TCL.PRE {} [get_runs impl_1]
}
